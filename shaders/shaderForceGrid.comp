// GLSL Compute Shader "ForceCS_Grid"
// Generated by XShaderCompiler
// 24/01/2019 16:02:44

#version 430

layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

struct Particle
{
    vec2 position;
    vec2 velocity;
};

struct ParticleForces
{
    vec2 acceleration;
};

struct ParticleDensity
{
    float density;
};

layout(std140) uniform cbSimulationConstants
{
    uint  g_iNumParticles;
    float g_fTimeStep;
    float g_fSmoothlen;
    float g_fPressureStiffness;
    float g_fRestDensity;
    float g_fDensityCoef;
    float g_fGradPressureCoef;
    float g_fLapViscosityCoef;
    float g_fWallStiffness;
    vec4  g_vGravity;
    vec4  g_vGridDim;
    vec3  g_vPlanes[4];
};

layout(std430) buffer xst_ParticlesRO
{
    readonly Particle ParticlesRO[];
};

layout(std430) buffer xst_ParticlesDensityRO
{
    readonly ParticleDensity ParticlesDensityRO[];
};

layout(std430) buffer xst_ParticlesForcesRW
{
    ParticleForces ParticlesForcesRW[];
};

layout(std430) buffer xst_GridIndicesRO
{
    readonly uvec2 GridIndicesRO[];
};

vec2 GridCalculateCell(vec2 position)
{
    return clamp(position * g_vGridDim.xy + g_vGridDim.zw, vec2(0, 0), vec2(255, 255));
}

int GridConstuctKey(uvec2 xy)
{
    return int(dot(xy.yx, uvec2(256, 1)));
}

float CalculatePressure(float density)
{
    return g_fPressureStiffness * max(pow(density / g_fRestDensity, 3.0f) - 1.0f, 0.0f);
}

vec2 CalculateGradPressure(float r, float P_pressure, float N_pressure, float N_density, vec2 diff)
{
    const float h = g_fSmoothlen;
    float avg_pressure = 0.5f * (N_pressure + P_pressure);
    return g_fGradPressureCoef * avg_pressure / N_density * (h - r) * (h - r) / r * (diff);
}

vec2 CalculateLapVelocity(float r, vec2 P_velocity, vec2 N_velocity, float N_density)
{
    const float h = g_fSmoothlen;
    vec2 vel_diff = (N_velocity - P_velocity);
    return g_fLapViscosityCoef / N_density * (h - r) * vel_diff;
}

void main()
{
    const int P_ID = int(gl_GlobalInvocationID.x);
    vec2 P_position = ParticlesRO[P_ID].position;
    vec2 P_velocity = ParticlesRO[P_ID].velocity;
    float P_density = ParticlesDensityRO[P_ID].density;
    float P_pressure = CalculatePressure(P_density);
    const float h_sq = g_fSmoothlen * g_fSmoothlen;
    vec2 acceleration = vec2(0, 0);
    ivec2 G_XY = ivec2(GridCalculateCell(P_position));
    for (int Y = max(G_XY.y - 1, 0); Y <= min(G_XY.y + 1, 255); Y++)
    {
        for (int X = max(G_XY.x - 1, 0); X <= min(G_XY.x + 1, 255); X++)
        {
            int G_CELL = GridConstuctKey(uvec2(X, Y));
            uvec2 G_START_END = GridIndicesRO[G_CELL];
            for (int N_ID = int(G_START_END.x); uint(N_ID) < G_START_END.y; N_ID++)
            {
                vec2 N_position = ParticlesRO[N_ID].position;
                vec2 diff = N_position - P_position;
                float r_sq = dot(diff, diff);
                if (r_sq < h_sq && P_ID != N_ID)
                {
                    vec2 N_velocity = ParticlesRO[N_ID].velocity;
                    float N_density = ParticlesDensityRO[N_ID].density;
                    float N_pressure = CalculatePressure(N_density);
                    float r = sqrt(r_sq);
                    acceleration += CalculateGradPressure(r, P_pressure, N_pressure, N_density, diff);
                    acceleration += CalculateLapVelocity(r, P_velocity, N_velocity, N_density);
                }
            }
        }
    }
    ParticlesForcesRW[P_ID].acceleration = acceleration / P_density;
}

